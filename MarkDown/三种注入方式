#@Autowired的三种使用方式

```java
@Service("accountEmailService")
public class AccountEmailServiceImpl implements AccountEmailService{
    /**  通过构造器注入---begin  **/
    private JavaMailSender javaMailSender;
    @Autowired
    public AccountEmailServiceImpl(JavaMailSender javaMailSender){
        this.javaMailSender = javaMailSender;
    }
    /** 通过构造器注入---end  **/
    /** 通过set方法注入---begin **/
    private JavaMailSender javaMailSender;
    @Autowired
    public void setJavaMailSender(JavaMailSender javaMailSender){
        this.javaMailSender = javaMailSender;
    }
    /** 通过set方法注入---end **/
    /** 通过field注入 **/
    @Autowired
    private JavaMailSender javaMailSender;
    @Override
    public void sendMail(String to, String subject, String htmlText) throws Exception{
        String systemMail = "xxx@qq.com";
        MimeMessage msg = javaMailSender.createMimeMessage();
        MimeMessageHelper messageHelper = new MimeMessageHelper(msg);
        messageHelper.setFrom(systemMail);
        messageHelper.setTo(to);
        messageHelper.setSubject(subject);
        messageHelper.setText(htmlText);
        javaMailSender.send(msg);
    }
}
```

##弊端
1. 如果你使用的是构造器注入
   当你有十几个甚至更多对象需要注入时，你的构造函数的参数个数可能会长到无法想像。
2. 如果你使用的是field反射注入
   如果不使用Spring框架，这个属性只能通过反射注入，太麻烦了！这根本不符合JavaBean规              范。 还有，当你不是用过Spring创建的对象时，还可能引起NullPointerException。 并且，你         不能用final修饰这个属性。
3. 如果你使用的是setter方法注入
   那么你将不能将属性设置为final。
两者取其轻
1. Spring3.0官方文档建议使用setter注入覆盖构造器注入。
2. Spring4.0官方文档建议使用构造器注入。

##结论
如果注入的属性是必选的属性，则通过构造器注入。
如果注入的属性是可选的属性，则通过setter方法注入。
至于field注入，不建议使用
